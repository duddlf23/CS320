#lang plai

; area-square: number number -> number
; to compute area of square whose two sides a, b
(define (area-square a b)
  (* a b))

(test (area-square 2 6) 12)
(test (area-square 5 4) 20)
(test (area-square 8 8) 64)


; volume-cuboid: number number number -> number
; to compute volume of cuboid whose three sides a, b, c
(define (volume-cuboid a b c)
  (* a b c))

(test (volume-cuboid 2 6 9) 108)
(test (volume-cuboid 10 10 10) 1000)
(test (volume-cuboid 20 5 70) 7000)


; is-multiple-of?: number number -> boolean
; to determine whether a is multiple of b
(define (is-multiple-of? a b)
  (= (remainder a b) 0))

(test (is-multiple-of? 8 2) true)
(test (is-multiple-of? 369 3) true)
(test (is-multiple-of? 13 2) false)


; factorial: number -> number
; to compute n!
(define (factorial n)
  (cond
    [(<= n 1) 1]
    [else (* n (factorial (- n 1)))]))

(test (factorial 0) 1)
(test (factorial 1) 1)
(test (factorial 5) 120)


; fibonacci: number -> number
; to compute n-th fibonacci number
(define (fibonacci n)
  (define (f a b cnt)
    (cond
      [(= cnt 0) b]
      [else (f (+ a b) a (- cnt 1))]))
  (f 1 0 n))


(test (fibonacci 1) 1)
(test (fibonacci 3) 2)
(test (fibonacci 7) 13)
(test (fibonacci 11) 89)


; define the type COURSE
(define-type COURSE
  [CS320 (quiz number?)
         (homework number?)]
  [CS311 (homework number?)]
  [CS330 (projects number?)
         (homework number?)])


; total-assignments: COURSE -> number
; to compute the total number of quizzes, homework,
; and projects for the given course c
(define (total-assignments c)
  (type-case COURSE c
    [CS320 (q h) (+ q h)]
    [CS311 (h) h]
    [CS330 (p h) (+ p h)]))

(test (total-assignments (CS320 3 7)) 10)
(test (total-assignments (CS320 0 0)) 00)
(test (total-assignments (CS311 50)) 50)
(test (total-assignments (CS311 2)) 2)
(test (total-assignments (CS330 9 7)) 16)
(test (total-assignments (CS330 0 8)) 8)


; total-homework: list -> number
; to compute the total number of homework
; of the courses in the given list l
(define (total-homework l)
  (cond
    [(empty? l) 0]
    [else (+
           (type-case COURSE (first l)
             [CS320 (q h) h]
             [CS311 (h) h]
             [CS330 (p h) h])
           (total-homework (rest l)))]))

(test (total-homework (list (CS320 3 8) (CS311 2))) 10)
(test (total-homework (list (CS330 19 0) (CS311 7))) 7)
(test (total-homework (list (CS320 3 8) (CS330 10 28))) 36)
(test (total-homework (list (CS320 3 8) (CS311 9) (CS330 1 17))) 34)
(test (total-homework (list (CS320 3 0) (CS311 0) (CS330 1 0))) 0)
(test (total-homework (list (CS320 3 2))) 2)
(test (total-homework (list (CS311 18))) 18)
(test (total-homework (list (CS330 3 0))) 0)


; my-map: function list -> list
; to produce a list of numbers generated by applying
; the input funciton f to each element of l
(define (my-map f l)
  (cond
    [(empty? l) empty]
    [else (cons (f (first l))
                (my-map f (rest l)))]))

(test (my-map fibonacci '(1 2 3 4 5 6 7 8 9 10)) '(1 1 2 3 5 8 13 21 34 55))
(test (my-map (lambda (x) (* 100 x)) '(3 6 9)) '(300 600 900))
(test (my-map (lambda (x) (remainder x 3)) '(1 2 3 4 5 6 7 8 9)) '(1 2 0 1 2 0 1 2 0))
(test (my-map factorial '(1 2 3 4 5 6)) '(1 2 6 24 120 720))


; my-filter: predicate list -> list
; to produce a list consisting of the elements
; of l that satisfy the predicate f
(define (my-filter f l)
  (cond
    [(empty? l) empty]
    [(f (first l)) (cons (first l)
                         (my-filter f (rest l)))]
    [else (my-filter f (rest l))]))

(test (my-filter (lambda (x) (= (remainder x 2) 1)) '(1 2 3 4 5 6 7 8 9 10)) '(1 3 5 7 9))
(test (my-filter (lambda (x) (= (remainder x 2) 0)) '(1 2 3 4 5 6 7 8 9 10)) '(2 4 6 8 10))
(test (my-filter (lambda (x) (> x 8)) '(1 300 4 0 10 15 5 6 8 9 11 12)) '(300 10 15 9 11 12))